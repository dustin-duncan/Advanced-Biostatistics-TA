---
title: "lab 3 copy complete"
author: "Dustin Duncan"
date: "2024-01-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(styler)
library(tidyverse)
library(rethinking)
library(bayesplot)
library(here)
library(hexbin)
library(data.table)
source("../helper.R")  
rm(list = ls())
```
# Bayesian Statistical Modeling Winter 2022
# Lab Exercise, Week 3

*When is this lab due?* Labs are due on the Thursday after they are assigned. However, in many cases you can complete them during the lab period itself.   This assignment is due on Thursday, 2/1/2024. Submit Rmd and pdf to gradescope.



### Medicago height data
We'll use publicly available data from:  https://figshare.com/articles/dataset/Medicago_truncatula_plant_height_data/8018873
The data we use are heights of the plant *Medicago truncatula*. The experiment in question was looking at the effect of plants on caterpillars, but we will just use the plant height data. It comes in multiple replicate observations, and we'll fit the mean and variance, using a normal distribution for the likelihood, for each replicate separately. 


Load the data. The code below is written assuming this Rmd file is saved in the same folder as the data file *MedicagoHeights.Rds*. You can copy the MedicagoHeights data to the same folder as your Rmd file. (Or, alternatively, you can give the path to the data in the load function.)
```{r ,eval=TRUE}
load("CopyOfMedicagoHeights.Rds")
view(plant.heights)
```

### Visualize and summarize the data
Plot histograms or density plots of height for each replicate and summarize the means and standard deviations of each replicate. You may use the `filter` function to pick data from specific replicates, or add `fill=Replicate` to the `aes` directive in ggplot. like this:
```{r ,eval=TRUE}
ggplot(  plant.heights    ,aes(x=height,fill=Replicate))  +
  geom_density(alpha=0.5) + 
  xlim(0, 250)
```


### Summarize the replicates
Summaries can be done using dplyr or by first subsetting the data to get each replicate and then using precis or mean and variance commands. 

```{r ,eval=TRUE}
plant.heights %>%
  group_by(Replicate) %>%
  summarise(mean=mean(height),  sd=sd(height)) 
```


### Fit the different replicates and see how they compare
We'll use a grid approximation to fit the means and standard deviations for each replicate separately. To get you started we'll define the log likelihood function. 

It requires that the height data be in a dataframe called `dataset` and a column called `height`. 

## Replicate One 

```{r define_like_function ,eval=TRUE}
# Setting up priors

nsamps <- 1e4
rep1_sim <- tibble(mu = rnorm(nsamps, mean = 100.67, sd = 25.35),
                   sigma = runif(nsamps, min = 0, max = 50)) %>% 
  mutate(y = rnorm(n(), mean = mu, sd = sigma))

# Plot your priors to see if they make sense

curve(dnorm(x, 100.67, 25.35), from = 0, to = 200)
# Implies that the average height is almost certainly between 75 and 125

curve(dunif(x, 0, 50), from = -10, to = 60)
# Constructing a flat prior for sigma constrains it to positive values. This makes sense because it must be positive. 
# What does it mean? A standard deviation of 50cm would indicate that 95% of individual heights lie within 100cm of the average height. That's a pretty large range. 
```


```{r}
dataset <- filter(plant.heights, Replicate == "Rep1")

height_loglik_f <- function(mu_input,sigma_input){
  sum(dnorm(
  dataset$height , 
  mean=mu_input,
  sd=sigma_input,
  log=TRUE ))
}


height_loglik_f_vec <- Vectorize(height_loglik_f)

# Grid approximation (defining grid)
set.seed(100)
n <- 200
rep1_grid <- tibble(mu = seq(from = 90, to = 120, length.out = n),
                    sigma = seq(from = 15, to = 40, length.out = n)) %>% 
  expand(mu, sigma)

# Compute the posterior 
rep1_posterior <- rep1_grid %>% 
  mutate(log_likelihood = height_loglik_f_vec(mu, sigma),
         log_prior_mu = dnorm(mu, 100, 20, log = TRUE),
         log_prior_sigma = dunif(sigma, min = 0, max = 50, log = TRUE),
         raw_log_posterior = log_likelihood + log_prior_mu + log_prior_sigma,
         log_posterior = raw_log_posterior - max(raw_log_posterior),
         raw_posterior = exp(log_posterior),
         posterior = raw_posterior/sum(raw_posterior))

# Compute the posterior a different way!

set.seed(100)
mu.list <- seq(from = 90, to = 120, length.out = 200)
set.seed(100)
sigma.list <- seq(from = 15, to = 40, length.out = 200)

post <- expand.grid(mu = mu.list, sigma = sigma.list)

post$LL <- sapply(1:nrow(post), function(i) sum(dnorm(dataset$height, post$mu[i], post$sigma[i], log = TRUE)))

post$prod <- post$LL + dnorm(post$mu, 100, 20, log = TRUE) + 
  dunif(post$sigma, 0, 50, log = TRUE)

post$prob <- exp(post$prod - max(post$prod))

contour_xyz(post$mu, post$sigma, post$prob)

# Checking posterior
sum(rep1_posterior$posterior)

# Viewing the posterior 

contour_xyz(rep1_posterior$mu, rep1_posterior$sigma, rep1_posterior$posterior)

# Sampling from the posterior 
set.seed(100)
rep1_pos_sample <- sample_n(rep1_posterior, size = 1e4, weight = posterior, replace = TRUE) %>% 
  select(mu, sigma, posterior)

# set.seed(100)
# rep1_pos_sample2 <- tibble(sample_mu = sample(rep1_posterior$mu, prob = rep1_posterior$posterior, size = 1e4, replace = TRUE),
#                            sample_sigma = sample(rep1_posterior$sigma, prob = rep1_posterior$posterior, size = 1e4, replace = TRUE)) %>% 
#   select(sample_mu, sample_sigma)

# Another Way!
set.seed(100)
sample.rows <- sample(1:nrow(post), size = 1e4, replace = TRUE, 
                      prob = post$prob)

sample.mu <- post$mu[sample.rows]

sample.sigma <- post$sigma[sample.rows]

precis(rep1_pos_sample)

# Checking posterior sample distribution 

ggplot(rep1_pos_sample, aes(mu, sigma)) + 
  geom_density_2d(bins = 10) + 
  lims(x = c(90, 120), y = c(15, 40))

plot(sample.mu, sample.sigma, cex = 0.5, pch = 16, col=col.alpha(rangi2, 0.1))

# Comparing marginal plots

ggplot(data = rep1_pos_sample, aes(x = mu)) + 
  geom_density(bw = .3)

ggplot(data = rep1_pos_sample, aes(x = sigma)) + 
  geom_density(bw = 0.3)

# Plotting samples from posteriors 

bayesplot:: mcmc_pairs(rep1_pos_sample, diag_fun = "dens",
                       off_diag_fun = "hex")
```

Now define a grid of $\mu$ and $\sigma$ values and then go through the same steps that we did in class to calculate the posterior probability for each $\mu$ and $\sigma$ pair. Do this seperately for each replicate in the dataset. In order to use the first replicate you would do:

```{r ,eval=TRUE}
dataset <- filter(plant.heights, Replicate == "Rep1") %>% # dataset is replicate 1
  rename(replicate = Replicate)
```


### Quantify the posterior distribution
Use the methods you have available to quantify the posterior distribution.

```{r Replicate 1 Quantification}
rep1_quant <- tibble(mean_mu = mean(rep1_posterior$mu),
                     median_mu = median(rep1_posterior$mu),
                     quantupper_mu = quantile(rep1_posterior$mu, 1 - 0.05),
                     quantlower_mu = quantile(rep1_posterior$mu, 0.05),
                     HPDI_mu = HPDI(rep1_posterior$mu, prob = 0.66),
                     mean_sigma = mean(rep1_posterior$sigma),
                     median_sigma = median(rep1_posterior$sigma),
                     quantupper_sigma = quantile(rep1_posterior$sigma, 1 - 0.05),
                     quantlower_sigma = quantile(rep1_posterior$sigma, 0.05),
                     HPDI_sigma = HPDI(rep1_posterior$sigma, prob = 0.66))
```



### Posterior simulations

Use the fitted model from replicate 1 to create a posterior simulation. This means that you will sample the values of $\mu$ and $\sigma$, and then produce an observation of *98 plant heights* (this is how many observations there are of each replicate), and find the mean of this simulated dataset. Simulate this 1,000 times, and compare the distribution of this mean to the actual mean of replicate 2. Describe what you see, is it what you expected?

*Remember, every posterior is also potentially a prior for a subsequent analysis, so you can process priors just like posteriors*

```{r Simulating Heights and Comparing}
# Plot predicted height against observed height for replicate one 

# Simulating predicted heights 

rep1_simulation <- tibble(mu = rnorm(1000, mean = mean(rep1_pos_sample$mu), sd = mean(rep1_pos_sample$sigma)),
                   sigma = runif(1000, min = min(rep1_pos_sample$sigma), max = max(rep1_pos_sample$sigma))) %>% 
  mutate(predicted_height = rnorm(n(), mean = mu, sd = sigma),
         replicate = "Rep1", 
         type = "predicted")

# Plotting predicted heights against actual data
ggplot()  +
  geom_density(data = rep1_simulation ,aes(x=predicted_height), fill = "forestgreen", alpha=0.5) + 
  geom_density(data = dataset, aes(x = height), fill = "tan", alpha = 0.5) +
  xlim(0, 250) + 
  labs(x = "Predicted Height Vs Observed Height", y = "Density of Observations", title = "Plotting Predicted Medicago Heights (green) against Observed Heights (tan)", fill = c("Predicted", "Observed"))
```

```{r}
dataset <- dataset %>% 
  mutate(type = "observed")

dataset$i <- rowid(dataset$replicate)
rep1_simulation$i <- rowid(rep1_simulation$replicate)

merged <- merge(dataset, rep1_simulation, by = c("replicate", "i"), all.x = TRUE)

merged2 <- merged %>% 
  pivot_longer(cols = c("height", "predicted_height"),
               names_to = "type2",
               values_to = "height")


ggplot() + 
  geom_point(data = merged, aes(x = height,y = predicted_height), alpha = 0.5) 

ggplot() + 
  geom_point(data = merged2, aes(x = i, y = height, color = type2, group_by = type2)) + 
  geom_jitter(stat = "identity", position = "dodge") + 
  scale_color_manual(values = c("tan", "forestgreen"))
```

## Conducting a quap to check all of my work

```{r}
m.1 <- quap( alist(
  height ~ dnorm(mu, sigma), 
  mu ~ dnorm(100, 25),
  sigma ~ dunif(0, 50)
), data = dataset
)

precis(m.1)

vcov(m.1)
diag( vcov( m.1 ))


cov2cor( vcov( m.1 ) )

post <- extract.samples(m.1, n = 1e4)
head(post)

plot(post)
```



### Extra credit
Do the same procedure for the other replicates. What can you say is similar or different about the replicates? Are there any anomalies?
